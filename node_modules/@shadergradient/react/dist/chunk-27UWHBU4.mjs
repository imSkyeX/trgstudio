import{DataTextureLoader as X,HalfFloatType as E,FloatType as P,DataUtils as G,LinearFilter as V}from"three";var R=class extends X{constructor(s){super(s),this.type=E}parse(s){let p=function(r,e){switch(r){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}},O=`
`,x=function(r,e,t){e=e||1024;let f=r.pos,a=-1,o=0,n="",m=String.fromCharCode.apply(null,new Uint16Array(r.subarray(f,f+128)));for(;0>(a=m.indexOf(O))&&o<e&&f<r.byteLength;)n+=m,o+=m.length,f+=128,m+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(f,f+128)));return-1<a?(t!==!1&&(r.pos+=o+a+1),n+m.slice(0,a)):!1},k=function(r){let e=/^#\?(\S+)/,t=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,f=/^\s*FORMAT=(\S+)\s*$/,a=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0},n,m;for((r.pos>=r.byteLength||!(n=x(r)))&&p(1,"no header found"),(m=n.match(e))||p(3,"bad initial token"),o.valid|=1,o.programtype=m[1],o.string+=n+`
`;n=x(r),n!==!1;){if(o.string+=n+`
`,n.charAt(0)==="#"){o.comments+=n+`
`;continue}if((m=n.match(t))&&(o.gamma=parseFloat(m[1])),(m=n.match(i))&&(o.exposure=parseFloat(m[1])),(m=n.match(f))&&(o.valid|=2,o.format=m[1]),(m=n.match(a))&&(o.valid|=4,o.height=parseInt(m[1],10),o.width=parseInt(m[2],10)),o.valid&2&&o.valid&4)break}return o.valid&2||p(3,"missing format specifier"),o.valid&4||p(3,"missing image size specifier"),o},U=function(r,e,t){let i=e;if(i<8||i>32767||r[0]!==2||r[1]!==2||r[2]&128)return new Uint8Array(r);i!==(r[2]<<8|r[3])&&p(3,"wrong scanline width");let f=new Uint8Array(4*e*t);f.length||p(4,"unable to allocate buffer space");let a=0,o=0,n=4*i,m=new Uint8Array(4),c=new Uint8Array(n),v=t;for(;v>0&&o<r.byteLength;){o+4>r.byteLength&&p(1),m[0]=r[o++],m[1]=r[o++],m[2]=r[o++],m[3]=r[o++],(m[0]!=2||m[1]!=2||(m[2]<<8|m[3])!=i)&&p(3,"bad rgbe scanline format");let g=0,l;for(;g<n&&o<r.byteLength;){l=r[o++];let d=l>128;if(d&&(l-=128),(l===0||g+l>n)&&p(3,"bad scanline data"),d){let h=r[o++];for(let H=0;H<l;H++)c[g++]=h}else c.set(r.subarray(o,o+l),g),g+=l,o+=l}let N=i;for(let d=0;d<N;d++){let h=0;f[a]=c[d+h],h+=i,f[a+1]=c[d+h],h+=i,f[a+2]=c[d+h],h+=i,f[a+3]=c[d+h],a+=4}v--}return f},I=function(r,e,t,i){let f=r[e+3],a=Math.pow(2,f-128)/255;t[i+0]=r[e+0]*a,t[i+1]=r[e+1]*a,t[i+2]=r[e+2]*a,t[i+3]=1},K=function(r,e,t,i){let f=r[e+3],a=Math.pow(2,f-128)/255;t[i+0]=G.toHalfFloat(Math.min(r[e+0]*a,65504)),t[i+1]=G.toHalfFloat(Math.min(r[e+1]*a,65504)),t[i+2]=G.toHalfFloat(Math.min(r[e+2]*a,65504)),t[i+3]=G.toHalfFloat(1)},T=new Uint8Array(s);T.pos=0;let L=k(T),F=L.width,w=L.height,C=U(T.subarray(T.pos),F,w),y,B,S;switch(this.type){case P:S=C.length/4;let r=new Float32Array(S*4);for(let t=0;t<S;t++)I(C,t*4,r,t*4);y=r,B=P;break;case E:S=C.length/4;let e=new Uint16Array(S*4);for(let t=0;t<S;t++)K(C,t*4,e,t*4);y=e,B=E;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:F,height:w,data:y,header:L.string,gamma:L.gamma,exposure:L.exposure,type:B}}setDataType(s){return this.type=s,this}load(s,u,M,D){function b(p,A){switch(p.type){case P:case E:"colorSpace"in p?p.colorSpace="srgb-linear":p.encoding=3e3,p.minFilter=V,p.magFilter=V,p.generateMipmaps=!1,p.flipY=!0;break}u&&u(p,A)}return super.load(s,b,M,D)}};import{useLoader as W}from"@react-three/fiber";function rr(_,{path:s}){return W(R,_,M=>M.setPath(s))}export{rr as a};
